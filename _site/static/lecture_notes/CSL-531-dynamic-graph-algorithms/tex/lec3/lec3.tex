\section{[Lecture] Jan 16, 2026}
We begin our discussion with some general comments on \emph{hardness} of problems.

\begin{lemma}\label{sec:lemma2}
    The \vocab{fully dynamic version} of a problem is at least as hard as the \vocab{partially dynamic version}.
\end{lemma}
\begin{proof}
    Suppose there exists a problem $\mathcal{P}$ for which the partially dynamic version version is \emph{harder} than the fully dynamic version. Consider an algorithm $A$ that solves the problem $\mathcal{P}$ in the fully dynamic version. Then the same algorithm can be used to solve the problem in the partially dynamic version with equal efficiency. This is because the fully dynamic version of $\mathcal{P}$ allows all types of updates. If we were to restrict the sequence of updates to only increments or decrements, we would have the partially dynamic version. This contradicts our assumption that the partially dynamic version is harder than the fully dynamic version.
\end{proof}

\begin{lemma}\label{sec:lemma3}
    A problem $\mathcal{P}$ on \vocab{directed graphs} is atleast as hard as if it were on \vocab{undirected graphs}.
\end{lemma}
\begin{proof}
    An undirected graph can be modelled as a directed graph by replacing each of its undirected edge $e(u, v)$ by two directed edges $d(u, v)$ and $d(v, u)$. Therefore, an algorithm $A$ that solves $\mathcal{P}$ on directed graphs can also be used to solve $\mathcal{P}$ on undirected graphs. Hence, the problem $\mathcal{P}$ on directed graphs is atleast as hard as it is on undirected graphs.
\end{proof}

\begin{lemma}\label{sec:lemma4}
    If $T_1$ and $T_2$ are the \highlight{amortized} and \highlight{worst-case} time complexities of a problem $\mathcal{P}$, then 
    \begin{equation*}
        T_1 \le T_2
    \end{equation*}
\end{lemma}
\begin{proof}
    This follows from
    \begin{align*}
        T_1 = \frac{\text{Total Time}}{\# \text{Updates}} \le \frac{T_2 \times \# \text{Updates}}{\# \text{Updates}} = T_2
    \end{align*}
\end{proof}

We now discuss the classic \vocab{single source reachability problem}, which is defined on directed graphs and asks if there exists a path from node $s$ to $t$ in a directed graph $G$. The undirected version of this problem is called the \vocab{connectivity problem}. We are interested in designing an incremental algorithm for the single source reachability problem.

\subsection{Static Single Source Reachability}
Consider the \emph{static single source reachability problem}.

\begin{problem}[Static Single Source Reachability]
    Given a directed graph $G(V, E)$ and a source vertex $s$ $\in$ $V$, design an algorithm to determine which vertices are reachable from $s$.
\end{problem}

This problem can be solved using either a \vocab{depth first search} (DFS) or a \vocab{breadth first search} (BFS) trasversal starting from $s$, which computes a \highlight{reachability tree} $T$ rooted at $s$. We maintain an array $R$ of size $n$ $=$ $\left| V \right|$, where 
\begin{align*}
    R[u] = \begin{cases}
        1, \qquad \text{if u is reachable from s}\\ 
        0, \qquad \text{otherwise}  
    \end{cases}
\end{align*}
Initially, all entries of $R$ are set to $0$. After computing the reachability tree $T$, we set $R[u] = 1$ for every vertex $u$ $\in$ $T$. Subsequently, \highlight{reachability queries} can be answered in constant time by checking if $R[u]$ $=$ $1$.

\begin{algorithm}[H]
    \caption{Static Single Source Reachability}
    \label{alg:static-reachability}
    \begin{algorithmic}[1]
        \Require Graph \(G(V,E)\), source vertex \(s \in V\)
        \Ensure Array \(R\) where \(R[u] = 1\) if and only if \(u\) is \emph{reachable} from \(s\)
        
        \ForAll{\(u \in V\)}
            \State \(R[u] \gets 0\)
        \EndFor
        
        \State Run \textsc{DFS} or \textsc{BFS} from \(s\), obtaining a reachability tree \(T\)
        
        \ForAll{\(u \in T\)}
            \State \(R[u] \gets 1\)
        \EndFor
        
        \State \Return \(R\)
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Reachability Query}
    \label{alg:reachability-query}
    \begin{algorithmic}[1]
        \Require Array \(R\), vertex \(u\)
        \Ensure \textbf{true} if \(u\) is \emph{reachable} from \(s\), otherwise \textbf{false}
        
        \If{\(R[u] = 1\)}
            \State \Return \textbf{true}
        \Else
            \State \Return \textbf{false}
        \EndIf
    \end{algorithmic}
\end{algorithm}
\begin{remark}
    Since we use a DFS/BFS, it takes \(\mathcal{O}(n+m)\) time for the algorithm to complete and each reachability query can be answered in \(\mathcal{O}(1)\) time. The algorithm uses \(\mathcal{O}(n)\) additional space for the array \(R\).
\end{remark}

\subsection{Incremental Single Source Reachability}
We now consider the \emph{incremental} version of the problem.

\begin{problem}[Incremental Single Source Reachability]
    Given a directed graph $G(V, E)$ having $n$ vertices and $m$ edges with a source vertex $s$ $\in$ $V$, design an \highlight{incremental algorithm} that computes all vertices reachable from $s$ under edge insertions to $G$.
\end{problem}

We are interested in maintaining the set of vertices reachable from the source vertex $s$ under edge insertions to the directed graph $G$. We begin with a few definitions before designing an algorithm for the problem.

\subsubsection{Definitions}
\begin{definition}
    Let $G(V, E)$ be a directed graph. Then we use $\leadsto$ to denote that there exists a directed path from $u$ to $v$ in $G$ and this is defined as the \emph{reachability relation}. A vertex $u$ is said to be \emph{reachable} from $s$ in $G$, if $s$ $\leadsto$ $u$. Similarly, a vertex $u$ is said to be \emph{unreachable} from $s$ in $G$, if there does not exist a path from $s$ to $v$.
\end{definition}

\begin{definition}
    Let $G(V, E)$ be a directed graph with source vertex $s$. A vertex $w$ is said to be \vocab{\emph{newly reachable}} from $s$, if after inserting $e(u, v)$ to $G$, the vertex $w$, which was previously unreachable from $s$, becomes reachable from $s$.
\end{definition}

\subsubsection{Algorithm}
Consider the insertion of a directed edge $e(u, v)$ to $G$. This edge insertion can only increase the set of vertices reachable from $s$. It can never remove any reachable vertex.

If $v$ is already reachable from $s$, then the insertion of $e$ has no effect. Similarly, if $u$ is not reachable from $s$, then adding an outgoing edge from $u$ cannot introduce any new reachable vertices.

However, if $u$ is reachable from $s$ and $v$ is not, then adding $e$ makes $v$ reachable from $s$. Moreover, every vertex reachable from $v$ that was previously unreachable from $s$ also becomes reachable from $s$. Therefore, we should \highlight{perform a graph traversal} starting from $v$ and add all vertices that are reachable from $v$ and previously unreachable from $s$ to our data structure.

\begin{algorithm}
    \caption{Incremental Single Source Reachability}
    \label{alg:incremental-reachability}
    \begin{algorithmic}[1]
        \Require Graph $G(V, E)$, source vertex $s$ $\in$ $V$
        \Ensure Array $R$ where $R[u] = 1$ if and only if $u$ is \emph{reachable} from $s$

        \Function{Update}{u, v}
            \If{$R[u] = 1$ and $R[v] = 0$}
                \State \(R[v] \gets 1\)
                \ForAll{\((v, w) \in E\)}
                    \State \Call{Update}{v, w}
                \EndFor
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsubsection{Correctness}
We will now prove the \highlight{correctness of the algorithm}. Essentially, we want to show that the algorithm correctly identifies all vertices that become newly reachable from $s$ after an edge insertion.

\begin{lemma}\label{sec:lemma5}
    Let $G(V, E)$ be a directed graph with a source vertex $s$. Adding a directed edge $e(u, v)$ to $G$ can never decrease the set of reachable vertices from $s$.
\end{lemma}
\begin{proof}
    Define $G'$ $=$ $(V, E \cup \{e(u, v)\})$. Clearly, every edge $e$ $\in$ $G(E)$ also belongs to $G'(E)$. Therefore, any path $p$ in $G$ also belongs to $G'$. Suppose $Q$ is the set of vertices reachable from $s$ in $G$. For every vertex $v$ $\in$ $Q$, let $p$ be the path from $s$ to $v$. Since $p$ also belongs to $G'$, therefore $v$ is reachable from $s$ in $G'$. Therefore, every vertex reachable from $s$ in $G$ remains reachable from $s$ in $G'$. Hence, adding a directed edge cannot decrease the set of reachable vertices from $s$.    
\end{proof}

\begin{lemma}[Reachability is Transitive]\label{sec:lemma6}
    Let $G(V, E)$ be a directed graph. Then the reachability relation $\leadsto$ is transitive. That is, $\forall$ $u$, $v$, $w$ $\in$ $G(V)$
    \begin{align*}
        u \leadsto v \;\text{and}\; v \leadsto w \;\implies\; u \leadsto w 
    \end{align*}
\end{lemma}
\begin{proof}
    Given that $u \leadsto v$ and $v \leadsto w$, we know that there exist directed paths $p_1$ and $p_2$ in $G$ that connect $u$ to $v$ and $v$ to $w$. Concatenating these paths to form a new path $p$ $=$ $p_1$ $\cup$ $p_2$ implies that $p$ is the directed path from $u$ to $w$ implying that $u$ $\leadsto$ $w$. 
\end{proof}

\begin{lemma}\label{sec:lemma7}
    Let $G(V, E)$ be a directed graph with a source vertex $s$. Adding a directed edge $e(u, v)$ to $G$ will increase the set of reachable vertices from $s$ \emph{if and only if} $u$ is reachable from $s$ and $v$ is not.
\end{lemma}
\begin{proof}
    If $u$ is reachable from $s$ and $v$ is not, then adding a directed edge from $u$ to $v$ makes $v$ reachable. Hence, the set of reachable vertices increases. 
    
    To prove the other direction, define $G'$ $=$ $(V, E \cup \{e(u, v)\})$. Suppose $v$ is reachable from $s$ in $G$. If adding the edge $e$ made a vertex $w$ newly reachable, then there exists a path $p$ from $s$ to $w$ in $G'$, but not in $G$. Since every edge $e$ $\in$ $G(E)$ also belongs to $G(E')$, hence $p$ must contain $e(u, v)$. We can conclude from here that $w$ must be reachable from $v$ in $G$. Using \vocab{\hyperref[sec:lemma6]{lemma 3.8}}, and $v$ being reachable from $s$ and $w$ from $v$ in $G$ implies that $w$ is reachable from $s$, contradicting the fact that $w$ is newly reachable. Hence, no such $w$ exists.

    Similarly, if $u$ is not reachable from $s$ and adding $e$ to $G$ makes a vertex $w$ newly reachable, then there exists a path $p$ from $s$ to $w$ in $G'$, but not in $G$. Since every edge $e$ $\in$ $G(E)$ also belongs to $G(E')$, hence $p$ must contain $e(u, v)$. However this implies that $u$ is reachable from $s$, contradicting our assumption. Hence, no such $w$ exists and the set of reachable vertices from $s$ does not increase.
\end{proof}

\paragraph{Main Proof.}
We now show that \vocab{\hyperref[alg:incremental-reachability]{Algorithm 3}} correctly computes the set of newly reachable vertices when a directed $e(u, v)$ is added to $G$. For the sake of contradiction, assume there exists a vertex $w$ which is newly reachable vertex and is not computed by the algorithm. 

By definition, $w$ is reachable from $s$ in $G'$ but not in $G$. Hence there must exist a path $p$ in $G' = (V, E \cup \{e(u, v)\})$ from $s$ to $w$ such that $p$ does not exist in $G$. Since all the edges $e$ $\in$ $G(E)$ also belongs to $G'(E)$, therefore the path $p$ must contain $e(u, v)$. Thus, $w$ is reachable from $v$ in $G'$. 

Now consider the path from $v$ to $w$. Consider any vertex $x$ on this path, such that $x \neq v, w$. Clearly $x$ is reachable from $s$ in $G'$. Furthermore, we can say that $x$ must be newly reachable too. If $x$ was previously reachable then, $w$ must have been previously reachable too because the path from $x$ to $w$ exists in $G$. Therefore, every vertex on this path is newly reachable. 

The algorithm first identifies \(v\) as newly reachable and then performs a traversal that marks every previously unreachable vertex reachable from \(v\). By induction on the length of the path, the algorithm must discover every vertex on the path from \(v\) to \(w\), including \(w\) itself.

This contradicts our assumption that \(w\) is not computed by the algorithm. Hence, no newly reachable vertex is missed, and the algorithm is correct. $\qquad \square$

\subsubsection{Time Complexity Analysis}
For \vocab{\hyperref[alg:incremental-reachability]{Algorithm 3}}, we show that the
\begin{enumerate}
    \item \highlight{Worst-case time complexity} is $\mathcal{O}\!\left( m + n \right)$.
    \begin{proof}
        If a vertex $u$ is newly reachable, then we perform $\left( 1 + \deg  u \right)$ operations on it. Thus, the total running time of the algorithm is
        \begin{align*}
            \sum_{u \in Q} \left( 1 + \deg u \right) = \mathcal{O}\!\left( m + n \right)
        \end{align*}
        where $Q$ is the set of newly reachable vertices.
    \end{proof}
    \item \highlight{Amortized time complexity} is $\mathcal{O}\!\left( 1 \right)$.
    \begin{proof}
        Since the algorithm reduces edges $e(u, v)$ of the form $$\left( R[u] = 1, R[v] = 0\right) \mapsto \left( R[u] = 1, R[v] = 1\right)$$ Hence, each edge could be reduced \emph{atmost once}. Thus, the number of operations are bounded by $m$ and the amortized time complexity turns out to be
        \[
            \frac{1}{m}
            \sum_{\substack{v \in V \\ R[v]=1}}
            \bigl(1 + \deg v\bigr)
            = \frac{\mathcal{O}(m+n)}{m}
            = \mathcal{O}(1)
        \]
    \end{proof}
\end{enumerate}
