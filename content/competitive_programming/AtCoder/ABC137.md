---
title: AtCoder ABC 137
math: true
type: docs
weight: 863
---

Today is 21st September, 2025 and I'm going to upsolve this <a href="https://atcoder.jp/contests/abc137">contest</a> (AtCoder ABC 137).

![alt text](image-11.png)

## Problem A <a href="https://atcoder.jp/contests/abc137/tasks/abc137_a">[Link]</a>

very trivial. just take the maximum of all three.

{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll a, b;
    std::cin >> a >> b;

    std::cout << std::max({a + b, a - b, a * b}) << '\n'; 
}  
```
{{% /details %}}

Submission Link: https://atcoder.jp/contests/abc137/submissions/69526851

## Problem B <a href="https://atcoder.jp/contests/abc137/tasks/abc137_b">[Link]</a>

this is easy too. just print all numbers from `x - k + 1` to `x + k - 1`


{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    int k, x;
    std::cin >> k >> x;

    for (int i = x - k + 1; i <= x + k - 1; i++) {
        std::cout << i << ' ';
    }
}
```
{{% /details %}}

Submission Link: https://atcoder.jp/contests/abc137/submissions/69526877

## Problem C <a href="https://atcoder.jp/contests/abc137/tasks/abc137_c">[Link]</a>

This problem caught me slacking hard. I wasn't really looking at the constraints and in a hurry I just read the problem and implemented an `O(N^2)` solution that checked the frequencies for each letter in a pair of strings. However, then I got a TLE and then I read the constraints lmao.

Then I hit on the right approach. Since the lengths of the string are small, we can just sort these and store them in a map. And just count the number of occurences for each string as we iterate over the list of strings. I still received two Wrong submissions because I was very careless with Integer Overflow here.

Here's the correct implementation:

{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll n;
    std::cin >> n;

    std::string s[n + 1];
    for (int i = 1; i <= n; i++) {
        std::cin >> s[i];
        std::sort(s[i].begin(), s[i].end());
    }

    ll cnt = 0;
    std::map<std::string, ll> mp;
    for (int i = 1; i <= n; i++) {
        cnt += mp[s[i]];
        mp[s[i]]++;
    }

    std::cout << cnt << '\n';
}
```
{{% /details %}}

Submission Link: https://atcoder.jp/contests/abc137/submissions/69527049

## Problem D <a href="https://atcoder.jp/contests/abc137/tasks/abc137_d">[Link]</a>

### Some Background
I immediately recognised this as the very same problem that was asked to me in my Goldman Sachs Intership On-Campus Interviews Round 1. That was one year ago and I didn't remember much now. But I think I still got stuck on the same issue as back then. Here's my complete thought process:

So for every passing day, each job is getting closer to the expiry. So if today is day `i` then we can only get rewards from jobs with `day <= m - i` and at any day `i` we should pick atmost one job. Is it optimal to pick a job that would give us the highest reward among the jobs left or should we pick up the highest reward among those that are going to expire soon. That is should we sort by `B` and then by `A` or should we sort by `A` and then by `B`. 

I got dead stuck in this approach. These types of problems have always been my weakness, my chaotic mind is really not able to play out well with opposing contradicting variables of motions. It's like it plays tug of war in my mind. 

Nevertheless, I implemented both the approaches that I could figure out and submitted and both of them gave my a Wrong Answer (WA) lmfao.

Then I read the editorial. The very beautiful and insightful editorial I've ever read (no sarcasm, I'm gonna link it here: https://img.atcoder.jp/abc137/editorial.pdf). Here's my own attempt at describing the idea.


### Idea
We will construct the solution backwards. Let's start from just one day before day `M`. we only have those jobs in our reach that will reward us in `1` day. What would we do? We would pick up those with highest rewards in this set. Then we move to day `2`. We have more possible jobs now. We will pick the highest from here. And so on. At every stage we are adding jobs that are permissible and then picking up the maximum from it. And no, this is not the same as picking up the maximum from all possible jobs when iterating in the forward direction. The order of picking up jobs changes and that actually gives you a Wrong Answer. 

To implement this, We will need to store all the jobs that expire on the `i`th day in a list and start iterating backwards, on each `i`th day, add all those jobs from the list to a priority queue that sorts jobs with highest reward and then by earliest expiry (actually this doesn't even matter) and just pick the highest rewarding job as long as you can.

Wow, that was actually very educational. There's another approach in the editorial that explains why a greedy strategy might work on this problem. It proves that the operations defined in this premise actually define a matroid and using the greedy algorithm on matroid we can actually work out this same exact solution.

### Implementation
{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll n, m;
    std::cin >> n >> m;

    ll a[n + 1], b[n + 1];
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i] >> b[i];
    }

    int day = 1, ans = 0;
    std::priority_queue<ll> pq;
    std::map<ll, std::vector<ll>> mp;
    for (int i = 1; i <= n; i++) {
        mp[a[i]].push_back(b[i]);
    }

    for (; day <= m; day++) {
        for (auto u: mp[day]) {
            pq.push(u);
        }
        if (pq.size()) {
            ans += pq.top();
            pq.pop();
        }
    }

    std::cout << ans << '\n';
} 
```
{{% /details %}}

Submission Link: https://atcoder.jp/contests/abc137/submissions/69538875

## Problem E <a href="https://atcoder.jp/contests/abc137/tasks/abc137_e">[Link]</a>

I immediately boiled down the condition of penalty of `TxP` to penalising all the edges of the graph by `P`. I realised that this might cause the graph edges to become negative weighted and therefore, we can no longer use `Dijkstra's algorithm` to determine the shortest length path. In such cases, it's a very well known fact that we use `Bellman-Ford's algorithm` but I'm really so rusty. I don't even remember how do you implement it.

So I decided to read about Bellman-Ford's Algorithm here: https://cp-algorithms.com/graph/bellman_ford.html

Then i implemented the following helper class for obtaining the shortest path distance vector using bellman-ford for a source node
```c++
// for bellman ford algorithm
struct Edge {
    int x;
    int y;
    int cost;
    Edge(int x, int y, int cost) : x(x), y(y), cost(cost) {}
};

class Bellman_Ford {
    // everything is 1-indexed
private:
    int source;
    int n;
    std::vector<struct Edge> edges;

public:
    int negative_cycle = 0;
    std::vector<ll> parent;

    Bellman_Ford(int u, int n, std::vector<struct Edge> edges): source(u), n(n), edges(edges), parent(n + 1, -1) {}

    std::vector<ll> run() {
        std::vector<ll> dist(n + 1, LLONG_MAX);
        
        // initialise the distance vector
        dist[source] = 0;

        for (int i = 1; i <= n; i++) {
            int flag = -1;

            for (auto edge: edges) {
                if (dist[edge.x] < LLONG_MAX) {
                    if (dist[edge.y] > dist[edge.x] + edge.cost) {
                        dist[edge.y] = std::max(LLONG_MIN, dist[edge.x] + edge.cost);
                        parent[edge.y] = edge.x;
                        flag = edge.y;
                    }
                }
            }

            if (flag == -1) break;
            if (i == n) {
                negative_cycle = flag;
            }
        }

        return dist;
    }
};
```

and I believe the algorithm is correct, but my submission gives a wrong answer: https://atcoder.jp/contests/abc137/submissions/69535537

I think I'll have to work out the theory and learn how to apply Bellman-Ford along with all the proofs. I'm gonna write a blog post about this that teaches bellman-ford along with the nitty gritty implementation tactics etc.

for now, the time is up and I'm still another problem short :(

![alt text](image-13.png)

![alt text](image-14.png)


## Problem F <a href="https://atcoder.jp/contests/abc137/tasks/abc137_f">[Link]</a>

![alt text](image-12.png)
