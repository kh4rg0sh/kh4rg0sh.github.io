---
title: AtCoder ABC 423
math: true
type: docs
weight: 577
---

Today, I participated as a rated participant in <a href="https://atcoder.jp/contests/abc423/tasks">ABC 423</a> and I managed to solve 6 out 7 problems. In this post, I'm going to talk about what I felt about each problem, briefly discuss about the ideas and cool tricks I learnt.

| ![](image.png) | 
|:--:| 
| *Performance* |

## Problem A

The language for this problem was quite confusing. I spent the first two minutes trying to understand what was I supposed to compute. Out of frustration I gave up and looked up the explanation in the examples. Through the explanation in the examples, I was able to figure out an algorithm to compute the required quantity.

Nothing too great about this problem. 

{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll x, c;
    std::cin >> x >> c;

    ll ans = x * (1000) / (1000 + c);
    ans = (ans / 1000) * 1000;

    std::cout << ans << '\n';
}
```
{{% /details %}}

## Problem B

Pretty straightforward. You just had to compute the maximum you can traverse from the left-most and right-most end and the count the number of rooms in between them. Trivial.

{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll n;
    std::cin >> n;

    ll a[n + 1];
    for (ll i = 1; i <= n; i++) std::cin >> a[i];

    ll l = 0, r = n;

    for (ll i = 1; i <= n; i++) {
        if (a[i] == 0) l++;
        else break;
    }

    for (ll i = n; i > 0; i--) {
        if (a[i] == 0) r--;
        else break;
    }

    if (l >= r) {
        std::cout << 0 << '\n';
    } else {
        std::cout << (r - l) - 1 << '\n';
    }
}   
```
{{% /details %}}

## Problem C

I had to think twice about this. Greedily, it seemed that you would choose the nearest end and walk back to the start and end up with closing all the doors on the other end. However, mathematically writing out the expression revealed that it doesn't matter as long as you move optimally (that is, a locked door would be operated on twice if you need to go past it to lock an unlocked door. And an unlocked door, would be only operated on a single time!). I'd say I liked this problem slightly!

{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll n, pos;
    std::cin >> n >> pos;

    ll a[n + 1];
    for (ll i = 1; i <= n; i++) std::cin >> a[i];

    ll left1 = 0, left2 = 0, right1 = 0, right2 = 0;

    ll cnt = 0;
    for (ll i = pos; i > 0; i--) {
        if (a[i] == 0) cnt++;
    }

    for (ll i = pos; i > 0; i--) {
        if (cnt == 0) break;
        if (a[i] == 1) left1++;
        else {
            left2++;
            cnt--;
        }

        
    }

    for (ll i = pos + 1; i <= n; i++) {
        if (a[i] == 0) cnt++;
    }

    for (ll i = pos + 1; i <= n; i++) {
        if (cnt == 0) break;
        if (a[i] == 1) right1++;
        else {
            right2++;
            cnt--;
        }
    }

    std::cout << left2 + 2 * left1 + right1 * 2 + right2 << '\n';
}  
```
{{% /details %}}

## Problem D

As soon as I read the problem, I had a feeling that this could be solved using an online algorithm (that is we can compute the answer for each query on the fly). the answers for the subsequent queries would be dependent on the answer of the previous query.

And as it turns out, you just have to maintain a sorted list of groups inside the restaurant. As long as you can fit groups inside, the groups will enter at their designated arrival time. When you cannot, you keep popping off groups that will leave the earliest, until there is enough room for the front facing group to enter. This is just implementation at this point. 

{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll n, k;
    std::cin >> n >> k;

    ll a[n + 1], b[n + 1], c[n + 1];
    for (ll i = 1; i <= n; i++) {
        std::cin >> a[i] >> b[i] >> c[i];
    }

    ll cap = 0, timer = 0;
    std::multiset<std::pair<ll, ll>> m;
    for (ll i = 1; i <= n; i++) {
        if (c[i] + cap <= k) {
            std::cout << std::max(a[i], timer) << '\n';
            m.insert({std::max(timer, a[i]) + b[i], -c[i]});
            timer = std::max(timer, a[i]);
            cap += c[i];
        } else {
            while (m.size() and c[i] + cap > k) {
                auto it = m.begin();
                cap += (*it).second;
                timer = std::max(timer, (*it).first);
                m.erase(it);
            }

            std::cout << std::max(a[i], timer) << '\n';
            m.insert({std::max(timer, a[i]) + b[i], -c[i]});
            timer = std::max(timer, a[i]);
            cap += c[i];
        }
    }
}
```
{{% /details %}}

## Problem E

I had seen this problem before hand somewhere. It is kinda stupid that this appeared on an ABC. I initially thought that it had something to do with custom plain segment trees. But, if you cleverly write the expression for each query in $[L, R]$ this is just prefix sums over three independent quantities.

{{% details title="Solution" closed="true" %}}
```c++
void solve() {
    ll n, q;
    std::cin >> n >> q;

    ll a[n + 1];
    for (ll i = 1; i <= n; i++) std::cin >> a[i];

    ll quad[n + 1], lin[n + 1], con[n + 1];
    for (ll i = 0; i <= n; i++) {
        quad[i] = 0;
        lin[i] = 0;
        con[i] = 0;
    }

    for (ll i = 1; i <= n; i++) {
        quad[i] = quad[i - 1] + a[i] * i * i;
        lin[i] = lin[i - 1] + a[i] * i;
        con[i] = con[i - 1] + a[i];
    }

    for (ll i = 1, x, y; i <= q; i++) {
        std::cin >> x >> y;

        ll ans = (y - x * y - x + 1) * (con[y] - con[x - 1]);
        ans += (x + y) * (lin[y] - lin[x - 1]);
        ans -= (quad[y] - quad[x - 1]);

        std::cout << ans << '\n';
    }
}
```
{{% /details %}}

## Problem F

Pretty popular idea again, I feel this is too easy for an ABC F. If we can calculate the number of numbers that are multiples of some $k$ terms, then using inclusion-exclusion principle we can compute the answer for exactly $m$ terms. for a subset of $k$ terms, any number that is a multiple of all these elements would be a multiple of their LCM. hence we just want to compute their LCM and compute the number of numbers that could be fit for the multiple of LCMs.

I liked this problem a lot. Pretty decent!


{{% details title="Solution" closed="true" %}}
```c++
ll lcm(ll x, ll y, ll overf) {
    if (x == 0 or y == 0) return 0;
    if (x / std::gcd(x, y) > overf / y ) {
        return overf + 1;
    } else {
        return (x / std::gcd(x, y)) * y;
    }
}

void solve() {
    ll n, m, y;
    std::cin >> n >> m >> y;

    ll a[n + 1];
    for (ll i = 1; i <= n; i++) std::cin >> a[i];

    ll binom[n + 1][n + 1];
    ll ans[n + 1];
    for (ll i = 0; i <= n; i++) {
        ans[i] = 0;
        for (ll j = 0; j <= n; j++) {
            binom[i][j] = 0;
        }
    }

    for (ll i = 0; i <= n; i++) {
        binom[i][i] = 1;
    }

    for (ll i = 1; i <= n; i++) {
        binom[i][0] = 1;
        for (ll j = 1; j <= i; j++) {
            binom[i][j] = binom[i - 1][j] + binom[i - 1][j - 1];
        }
    }

    for (ll i = 0; i < (1LL << n); i++) {
        ll ones = __builtin_popcount(i);

        ll lcm_sub = 1;
        ll overflow = 0;
        for (ll j = 0; j < n; j++) {
            if (i & (1LL << j)) {
                lcm_sub = lcm(lcm_sub, a[j + 1], y);
                if (lcm_sub > y) {
                    overflow = 1;
                    break;
                }
            }
        }
        if (!overflow) {
            ans[ones] += y / lcm_sub;
        } 
    }

    ll fin = 0;
    for (ll i = m; i <= n; i++) {
        if ((i - m) % 2) {
            fin -= binom[i][m] * ans[i];
        } else {
            fin += binom[i][m] * ans[i];
        }
    }
    
    std::cout << fin << '\n';
}
```
{{% /details %}}

